// Code generated by protoc-gen-go. DO NOT EDIT.
// source: opencensus/proto/stats/metrics/metrics.proto

/*
Package metricsproto is a generated protocol buffer package.

It is generated from these files:
	opencensus/proto/stats/metrics/metrics.proto

It has these top-level messages:
	MetricSet
	Metric
	MetricDescriptor
	LabelKey
	TimeSeries
	LabelValue
	GaugePoint
	CumulativePoint
	DistributionValue
*/
package metricsproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The kind of metric. It describes how the data is reported.
type MetricDescriptor_Type int32

const (
	// Do not use this default value.
	MetricDescriptor_UNSPECIFIED MetricDescriptor_Type = 0
	// An instantaneous measurement of a value.
	MetricDescriptor_GAUGE MetricDescriptor_Type = 1
	// A value accumulated over a time interval. Cumulative measurements in a
	// time series should have the same start time and increasing end times,
	// until an event resets the cumulative value to zero and sets a new
	// start time for the following points.
	MetricDescriptor_CUMULATIVE MetricDescriptor_Type = 2
)

var MetricDescriptor_Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GAUGE",
	2: "CUMULATIVE",
}
var MetricDescriptor_Type_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GAUGE":       1,
	"CUMULATIVE":  2,
}

func (x MetricDescriptor_Type) String() string {
	return proto.EnumName(MetricDescriptor_Type_name, int32(x))
}
func (MetricDescriptor_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// A collection of Metrics, used for batching.
type MetricSet struct {
	// Each Metric has one or more timeseries.
	Metrics []*Metric `protobuf:"bytes,1,rep,name=metrics" json:"metrics,omitempty"`
}

func (m *MetricSet) Reset()                    { *m = MetricSet{} }
func (m *MetricSet) String() string            { return proto.CompactTextString(m) }
func (*MetricSet) ProtoMessage()               {}
func (*MetricSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MetricSet) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Defines a Metric which has one or more timeseries.
type Metric struct {
	// The definition of the Metric. For now, we send the full MetricDescriptor
	// every time in order to keep the protocol stateless, but this is one of the
	// places where we can make future changes to make the protocol more
	// efficient.
	MetricDescriptor *MetricDescriptor `protobuf:"bytes,1,opt,name=metric_descriptor,json=metricDescriptor" json:"metric_descriptor,omitempty"`
	// One or more timeseries for a single metric, where each timeseries has
	// one or more points.
	Timeseries []*TimeSeries `protobuf:"bytes,2,rep,name=timeseries" json:"timeseries,omitempty"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (m *Metric) String() string            { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Metric) GetMetricDescriptor() *MetricDescriptor {
	if m != nil {
		return m.MetricDescriptor
	}
	return nil
}

func (m *Metric) GetTimeseries() []*TimeSeries {
	if m != nil {
		return m.Timeseries
	}
	return nil
}

// Defines a metric type and its schema.
type MetricDescriptor struct {
	// The metric type, including its DNS name prefix. It must be unique.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A detailed description of the metric, which can be used in documentation.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// The unit in which the metric value is reported. Follows the format
	// described by http://unitsofmeasure.org/ucum.html.
	Unit string                `protobuf:"bytes,3,opt,name=unit" json:"unit,omitempty"`
	Type MetricDescriptor_Type `protobuf:"varint,4,opt,name=type,enum=opencensus.proto.stats.metrics.MetricDescriptor_Type" json:"type,omitempty"`
	// The label keys associated with the metric descriptor.
	LabelKeys []*LabelKey `protobuf:"bytes,5,rep,name=label_keys,json=labelKeys" json:"label_keys,omitempty"`
}

func (m *MetricDescriptor) Reset()                    { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string            { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()               {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *MetricDescriptor) GetType() MetricDescriptor_Type {
	if m != nil {
		return m.Type
	}
	return MetricDescriptor_UNSPECIFIED
}

func (m *MetricDescriptor) GetLabelKeys() []*LabelKey {
	if m != nil {
		return m.LabelKeys
	}
	return nil
}

// Defines a label key associated with a metric descriptor.
type LabelKey struct {
	// The key for the label.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// A human-readable description of what this label key represents.
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *LabelKey) Reset()                    { *m = LabelKey{} }
func (m *LabelKey) String() string            { return proto.CompactTextString(m) }
func (*LabelKey) ProtoMessage()               {}
func (*LabelKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *LabelKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LabelKey) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// A collection of data points that describes the time-varying values
// of a metric.
type TimeSeries struct {
	// TODO: Add restrictions for characters that can be used for keys and values.
	// The set of label values that uniquely identify this timeseries. Apply to all
	// points. The order of label values must match that of label keys in the
	// metric descriptor.
	LabelValues []*LabelValue `protobuf:"bytes,1,rep,name=label_values,json=labelValues" json:"label_values,omitempty"`
	// The data points of this timeseries. Point type MUST match the MetricDescriptor.type, so for
	// a CUMULATIVE type only cumulative_points are present and for a GAUGE type only gauge_points
	// are present.
	GaugePoints      []*GaugePoint      `protobuf:"bytes,2,rep,name=gauge_points,json=gaugePoints" json:"gauge_points,omitempty"`
	CumulativePoints []*CumulativePoint `protobuf:"bytes,3,rep,name=cumulative_points,json=cumulativePoints" json:"cumulative_points,omitempty"`
}

func (m *TimeSeries) Reset()                    { *m = TimeSeries{} }
func (m *TimeSeries) String() string            { return proto.CompactTextString(m) }
func (*TimeSeries) ProtoMessage()               {}
func (*TimeSeries) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TimeSeries) GetLabelValues() []*LabelValue {
	if m != nil {
		return m.LabelValues
	}
	return nil
}

func (m *TimeSeries) GetGaugePoints() []*GaugePoint {
	if m != nil {
		return m.GaugePoints
	}
	return nil
}

func (m *TimeSeries) GetCumulativePoints() []*CumulativePoint {
	if m != nil {
		return m.CumulativePoints
	}
	return nil
}

type LabelValue struct {
	// The value for the label.
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	// If false the value field is ignored and considered not set.
	HasValue bool `protobuf:"varint,2,opt,name=has_value,json=hasValue" json:"has_value,omitempty"`
}

func (m *LabelValue) Reset()                    { *m = LabelValue{} }
func (m *LabelValue) String() string            { return proto.CompactTextString(m) }
func (*LabelValue) ProtoMessage()               {}
func (*LabelValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LabelValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *LabelValue) GetHasValue() bool {
	if m != nil {
		return m.HasValue
	}
	return false
}

// An instantaneous measurement of a value.
type GaugePoint struct {
	// The moment when this gauge point was recorded.
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The actual point value.
	//
	// Types that are valid to be assigned to Value:
	//	*GaugePoint_Int64Value
	//	*GaugePoint_DoubleValue
	Value isGaugePoint_Value `protobuf_oneof:"value"`
}

func (m *GaugePoint) Reset()                    { *m = GaugePoint{} }
func (m *GaugePoint) String() string            { return proto.CompactTextString(m) }
func (*GaugePoint) ProtoMessage()               {}
func (*GaugePoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isGaugePoint_Value interface {
	isGaugePoint_Value()
}

type GaugePoint_Int64Value struct {
	Int64Value int64 `protobuf:"varint,2,opt,name=int64_value,json=int64Value,oneof"`
}
type GaugePoint_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,3,opt,name=double_value,json=doubleValue,oneof"`
}

func (*GaugePoint_Int64Value) isGaugePoint_Value()  {}
func (*GaugePoint_DoubleValue) isGaugePoint_Value() {}

func (m *GaugePoint) GetValue() isGaugePoint_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GaugePoint) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *GaugePoint) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*GaugePoint_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *GaugePoint) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*GaugePoint_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GaugePoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GaugePoint_OneofMarshaler, _GaugePoint_OneofUnmarshaler, _GaugePoint_OneofSizer, []interface{}{
		(*GaugePoint_Int64Value)(nil),
		(*GaugePoint_DoubleValue)(nil),
	}
}

func _GaugePoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GaugePoint)
	// value
	switch x := m.Value.(type) {
	case *GaugePoint_Int64Value:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int64Value))
	case *GaugePoint_DoubleValue:
		b.EncodeVarint(3<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case nil:
	default:
		return fmt.Errorf("GaugePoint.Value has unexpected type %T", x)
	}
	return nil
}

func _GaugePoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GaugePoint)
	switch tag {
	case 2: // value.int64_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &GaugePoint_Int64Value{int64(x)}
		return true, err
	case 3: // value.double_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &GaugePoint_DoubleValue{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _GaugePoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GaugePoint)
	// value
	switch x := m.Value.(type) {
	case *GaugePoint_Int64Value:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64Value))
	case *GaugePoint_DoubleValue:
		n += proto.SizeVarint(3<<3 | proto.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Measurements accumulated over a time interval.
type CumulativePoint struct {
	// This must be the same until an event resets the cumulative value to zero
	// and sets a new start for the following points.
	StartTime *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The end timestamp of the accumulated measurement.
	EndTime *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// The actual point value.
	//
	// Types that are valid to be assigned to Value:
	//	*CumulativePoint_Int64Value
	//	*CumulativePoint_DoubleValue
	//	*CumulativePoint_DistributionValue
	Value isCumulativePoint_Value `protobuf_oneof:"value"`
}

func (m *CumulativePoint) Reset()                    { *m = CumulativePoint{} }
func (m *CumulativePoint) String() string            { return proto.CompactTextString(m) }
func (*CumulativePoint) ProtoMessage()               {}
func (*CumulativePoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isCumulativePoint_Value interface {
	isCumulativePoint_Value()
}

type CumulativePoint_Int64Value struct {
	Int64Value int64 `protobuf:"varint,3,opt,name=int64_value,json=int64Value,oneof"`
}
type CumulativePoint_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,oneof"`
}
type CumulativePoint_DistributionValue struct {
	DistributionValue *DistributionValue `protobuf:"bytes,5,opt,name=distribution_value,json=distributionValue,oneof"`
}

func (*CumulativePoint_Int64Value) isCumulativePoint_Value()        {}
func (*CumulativePoint_DoubleValue) isCumulativePoint_Value()       {}
func (*CumulativePoint_DistributionValue) isCumulativePoint_Value() {}

func (m *CumulativePoint) GetValue() isCumulativePoint_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CumulativePoint) GetStartTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *CumulativePoint) GetEndTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *CumulativePoint) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*CumulativePoint_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *CumulativePoint) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*CumulativePoint_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *CumulativePoint) GetDistributionValue() *DistributionValue {
	if x, ok := m.GetValue().(*CumulativePoint_DistributionValue); ok {
		return x.DistributionValue
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CumulativePoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CumulativePoint_OneofMarshaler, _CumulativePoint_OneofUnmarshaler, _CumulativePoint_OneofSizer, []interface{}{
		(*CumulativePoint_Int64Value)(nil),
		(*CumulativePoint_DoubleValue)(nil),
		(*CumulativePoint_DistributionValue)(nil),
	}
}

func _CumulativePoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CumulativePoint)
	// value
	switch x := m.Value.(type) {
	case *CumulativePoint_Int64Value:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int64Value))
	case *CumulativePoint_DoubleValue:
		b.EncodeVarint(4<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case *CumulativePoint_DistributionValue:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DistributionValue); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CumulativePoint.Value has unexpected type %T", x)
	}
	return nil
}

func _CumulativePoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CumulativePoint)
	switch tag {
	case 3: // value.int64_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &CumulativePoint_Int64Value{int64(x)}
		return true, err
	case 4: // value.double_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &CumulativePoint_DoubleValue{math.Float64frombits(x)}
		return true, err
	case 5: // value.distribution_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DistributionValue)
		err := b.DecodeMessage(msg)
		m.Value = &CumulativePoint_DistributionValue{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CumulativePoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CumulativePoint)
	// value
	switch x := m.Value.(type) {
	case *CumulativePoint_Int64Value:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int64Value))
	case *CumulativePoint_DoubleValue:
		n += proto.SizeVarint(4<<3 | proto.WireFixed64)
		n += 8
	case *CumulativePoint_DistributionValue:
		s := proto.Size(x.DistributionValue)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Distribution contains summary statistics for a population of values. It
// optionally contains a histogram representing the distribution of those
// values across a set of buckets.
type DistributionValue struct {
	// The number of values in the population. Must be non-negative. This value
	// must equal the sum of the values in bucket_counts if a histogram is
	// provided.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// The arithmetic mean of the values in the population. If count is zero
	// then this field must be zero.
	Mean float64 `protobuf:"fixed64,2,opt,name=mean" json:"mean,omitempty"`
	// The sum of squared deviations from the mean of the values in the
	// population. For values x_i this is:
	//
	//     Sum[i=1..n]((x_i - mean)^2)
	//
	// Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
	// describes Welford's method for accumulating this sum in one pass.
	//
	// If count is zero then this field must be zero.
	SumOfSquaredDeviation float64 `protobuf:"fixed64,3,opt,name=sum_of_squared_deviation,json=sumOfSquaredDeviation" json:"sum_of_squared_deviation,omitempty"`
	// If specified, contains the range of the population values. The field
	// must not be present if the count is zero.
	Range *DistributionValue_Range `protobuf:"bytes,4,opt,name=range" json:"range,omitempty"`
	// A Distribution may optionally contain a histogram of the values in the
	// population. The bucket boundaries for that histogram are described by
	// bucket_bounds. This defines size(bucket_bounds) + 1 (= N)
	// buckets. The boundaries for bucket index i are:
	//
	// (-infinity, bucket_bounds[i]) for i == 0
	// [bucket_bounds[i-1], bucket_bounds[i]) for 0 < i < N-2
	// [bucket_bounds[i-1], +infinity) for i == N-1
	//
	// i.e. an underflow bucket (number 0), zero or more finite buckets (1
	// through N - 2, and an overflow bucket (N - 1), with inclusive lower
	// bounds and exclusive upper bounds.
	//
	// If bucket_bounds has no elements (zero size), then there is no
	// histogram associated with the Distribution. If bucket_bounds has only
	// one element, there are no finite buckets, and that single element is the
	// common boundary of the overflow and underflow buckets. The values must
	// be monotonically increasing.
	BucketBounds []float64 `protobuf:"fixed64,5,rep,packed,name=bucket_bounds,json=bucketBounds" json:"bucket_bounds,omitempty"`
	// If the distribution does not have a histogram, then omit this field.
	// If there is a histogram, then the sum of the values in the Bucket counts
	// must equal the value in the count field of the distribution.
	Buckets []*DistributionValue_Bucket `protobuf:"bytes,6,rep,name=buckets" json:"buckets,omitempty"`
}

func (m *DistributionValue) Reset()                    { *m = DistributionValue{} }
func (m *DistributionValue) String() string            { return proto.CompactTextString(m) }
func (*DistributionValue) ProtoMessage()               {}
func (*DistributionValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DistributionValue) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *DistributionValue) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *DistributionValue) GetSumOfSquaredDeviation() float64 {
	if m != nil {
		return m.SumOfSquaredDeviation
	}
	return 0
}

func (m *DistributionValue) GetRange() *DistributionValue_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *DistributionValue) GetBucketBounds() []float64 {
	if m != nil {
		return m.BucketBounds
	}
	return nil
}

func (m *DistributionValue) GetBuckets() []*DistributionValue_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// The range of the population values.
type DistributionValue_Range struct {
	// The minimum of the population values.
	Min float64 `protobuf:"fixed64,1,opt,name=min" json:"min,omitempty"`
	// The maximum of the population values.
	Max float64 `protobuf:"fixed64,2,opt,name=max" json:"max,omitempty"`
}

func (m *DistributionValue_Range) Reset()                    { *m = DistributionValue_Range{} }
func (m *DistributionValue_Range) String() string            { return proto.CompactTextString(m) }
func (*DistributionValue_Range) ProtoMessage()               {}
func (*DistributionValue_Range) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *DistributionValue_Range) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *DistributionValue_Range) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

type DistributionValue_Bucket struct {
	// The number of values in each bucket of the histogram, as described in
	// bucket_bounds.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
}

func (m *DistributionValue_Bucket) Reset()                    { *m = DistributionValue_Bucket{} }
func (m *DistributionValue_Bucket) String() string            { return proto.CompactTextString(m) }
func (*DistributionValue_Bucket) ProtoMessage()               {}
func (*DistributionValue_Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

func (m *DistributionValue_Bucket) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*MetricSet)(nil), "opencensus.proto.stats.metrics.MetricSet")
	proto.RegisterType((*Metric)(nil), "opencensus.proto.stats.metrics.Metric")
	proto.RegisterType((*MetricDescriptor)(nil), "opencensus.proto.stats.metrics.MetricDescriptor")
	proto.RegisterType((*LabelKey)(nil), "opencensus.proto.stats.metrics.LabelKey")
	proto.RegisterType((*TimeSeries)(nil), "opencensus.proto.stats.metrics.TimeSeries")
	proto.RegisterType((*LabelValue)(nil), "opencensus.proto.stats.metrics.LabelValue")
	proto.RegisterType((*GaugePoint)(nil), "opencensus.proto.stats.metrics.GaugePoint")
	proto.RegisterType((*CumulativePoint)(nil), "opencensus.proto.stats.metrics.CumulativePoint")
	proto.RegisterType((*DistributionValue)(nil), "opencensus.proto.stats.metrics.DistributionValue")
	proto.RegisterType((*DistributionValue_Range)(nil), "opencensus.proto.stats.metrics.DistributionValue.Range")
	proto.RegisterType((*DistributionValue_Bucket)(nil), "opencensus.proto.stats.metrics.DistributionValue.Bucket")
	proto.RegisterEnum("opencensus.proto.stats.metrics.MetricDescriptor_Type", MetricDescriptor_Type_name, MetricDescriptor_Type_value)
}

func init() { proto.RegisterFile("opencensus/proto/stats/metrics/metrics.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0x23, 0x35,
	0x14, 0xee, 0xe4, 0xa7, 0x6d, 0xce, 0x94, 0xdd, 0xd4, 0x02, 0x69, 0xd4, 0x95, 0x96, 0x32, 0x2b,
	0xa1, 0x6a, 0xa1, 0x13, 0x08, 0x2c, 0xbb, 0xdc, 0x00, 0x9b, 0xb6, 0xb4, 0x85, 0x0d, 0x14, 0xb7,
	0xdd, 0x0b, 0x04, 0x1a, 0xcd, 0x8f, 0x3b, 0xb5, 0x3a, 0xe3, 0x09, 0x63, 0xbb, 0x22, 0x77, 0x5c,
	0x22, 0xf1, 0x00, 0xbc, 0x00, 0x6f, 0xc0, 0x0d, 0x8f, 0x87, 0x7c, 0x3c, 0xf9, 0x21, 0x5b, 0x91,
	0xf4, 0x2a, 0xc7, 0x9f, 0xcf, 0xf7, 0xf9, 0x9c, 0x2f, 0xc7, 0x1e, 0xf8, 0xb0, 0x1c, 0x31, 0x91,
	0x30, 0x21, 0xb5, 0xec, 0x8d, 0xaa, 0x52, 0x95, 0x3d, 0xa9, 0x22, 0x25, 0x7b, 0x05, 0x53, 0x15,
	0x4f, 0xa6, 0xbf, 0x01, 0xee, 0x91, 0xc7, 0xb3, 0x6c, 0x8b, 0x04, 0x98, 0x1d, 0xd4, 0x59, 0x3b,
	0xef, 0x66, 0x65, 0x99, 0xe5, 0xcc, 0x2a, 0xc5, 0xfa, 0xaa, 0xa7, 0x78, 0xc1, 0xa4, 0x8a, 0x8a,
	0x91, 0x4d, 0xf7, 0x87, 0xd0, 0x19, 0x62, 0xee, 0x39, 0x53, 0xe4, 0x2b, 0xd8, 0xa8, 0x89, 0x9e,
	0xb3, 0xdb, 0xdc, 0x73, 0xfb, 0xef, 0x07, 0xff, 0xaf, 0x1f, 0x58, 0x2e, 0x9d, 0xd0, 0xfc, 0xbf,
	0x1d, 0x58, 0xb7, 0x18, 0xf9, 0x19, 0xb6, 0x2d, 0x1a, 0xa6, 0x4c, 0x26, 0x15, 0x1f, 0xa9, 0xb2,
	0xf2, 0x9c, 0x5d, 0x67, 0xcf, 0xed, 0x7f, 0xb4, 0x9a, 0xec, 0xe1, 0x94, 0x47, 0xbb, 0xc5, 0x02,
	0x42, 0xbe, 0x01, 0xc0, 0x5e, 0x58, 0xc5, 0x99, 0xf4, 0x1a, 0x58, 0xee, 0xd3, 0x65, 0xba, 0x17,
	0xbc, 0x60, 0xe7, 0xc8, 0xa0, 0x73, 0x6c, 0xff, 0xaf, 0x06, 0x74, 0x17, 0x8f, 0x24, 0x04, 0x5a,
	0x22, 0x2a, 0x18, 0x96, 0xdc, 0xa1, 0x18, 0x93, 0x5d, 0x70, 0x27, 0xcd, 0xf0, 0x52, 0x78, 0x0d,
	0xdc, 0x9a, 0x87, 0x0c, 0x4b, 0x0b, 0xae, 0xbc, 0xa6, 0x65, 0x99, 0x98, 0x9c, 0x42, 0x4b, 0x8d,
	0x47, 0xcc, 0x6b, 0xed, 0x3a, 0x7b, 0x0f, 0xfa, 0xcf, 0xee, 0xdb, 0x7c, 0x70, 0x31, 0x1e, 0x31,
	0x8a, 0x12, 0xe4, 0x18, 0x20, 0x8f, 0x62, 0x96, 0x87, 0x37, 0x6c, 0x2c, 0xbd, 0x36, 0x76, 0xbd,
	0xb7, 0x4c, 0xf0, 0x95, 0x61, 0x7c, 0xcb, 0xc6, 0xb4, 0x93, 0xd7, 0x91, 0xf4, 0xfb, 0xd0, 0x32,
	0xb2, 0xe4, 0x21, 0xb8, 0x97, 0xdf, 0x9d, 0x9f, 0x1d, 0x1d, 0x9c, 0x7e, 0x7d, 0x7a, 0x74, 0xd8,
	0x5d, 0x23, 0x1d, 0x68, 0x1f, 0xbf, 0xbc, 0x3c, 0x3e, 0xea, 0x3a, 0xe4, 0x01, 0xc0, 0xc1, 0xe5,
	0xf0, 0xf2, 0xd5, 0xcb, 0x8b, 0xd3, 0xd7, 0x47, 0xdd, 0x86, 0xff, 0x05, 0x6c, 0x4e, 0xa4, 0x48,
	0x17, 0x9a, 0x37, 0x6c, 0x5c, 0x9b, 0x63, 0xc2, 0xe5, 0xde, 0xf8, 0xbf, 0x37, 0x00, 0x66, 0xff,
	0x00, 0x19, 0xc2, 0x96, 0xed, 0xe5, 0x36, 0xca, 0x35, 0x9b, 0x8c, 0xdc, 0xd3, 0x95, 0xba, 0x79,
	0x6d, 0x28, 0xd4, 0xcd, 0xa7, 0x31, 0xca, 0x65, 0x91, 0xce, 0x58, 0x38, 0x2a, 0xb9, 0x50, 0x2b,
	0x8f, 0xc4, 0xb1, 0xe1, 0x9c, 0x19, 0x0a, 0x75, 0xb3, 0x69, 0x2c, 0xc9, 0x4f, 0xb0, 0x9d, 0xe8,
	0x42, 0xe7, 0x91, 0xe2, 0xb7, 0x53, 0xcd, 0x26, 0x6a, 0xf6, 0x96, 0x69, 0x1e, 0x4c, 0x89, 0x56,
	0xb8, 0x9b, 0xfc, 0x17, 0x90, 0xfe, 0x97, 0x00, 0xb3, 0x3e, 0xc8, 0xdb, 0xd0, 0x46, 0x0f, 0x6a,
	0x3b, 0xed, 0x82, 0x3c, 0x82, 0xce, 0x75, 0x24, 0xad, 0x3b, 0x68, 0xe7, 0x26, 0xdd, 0xbc, 0x8e,
	0x24, 0x52, 0xfc, 0x3f, 0x1d, 0x80, 0x59, 0xe9, 0xe4, 0x05, 0x74, 0xa6, 0x37, 0xbb, 0xbe, 0x64,
	0x3b, 0x81, 0xbd, 0xfb, 0xc1, 0xe4, 0xee, 0xe3, 0xf4, 0x63, 0x06, 0x9d, 0x25, 0x93, 0xf7, 0xc0,
	0xe5, 0x42, 0x7d, 0xf6, 0xe9, 0xdc, 0x39, 0xcd, 0x93, 0x35, 0x0a, 0x08, 0xda, 0xf2, 0x9e, 0xc0,
	0x56, 0x5a, 0xea, 0x38, 0x67, 0x75, 0x8e, 0x99, 0x6d, 0xe7, 0x64, 0x8d, 0xba, 0x16, 0xc5, 0xa4,
	0xc1, 0x46, 0xdd, 0x83, 0xff, 0x4f, 0x03, 0x1e, 0x2e, 0x18, 0x40, 0x3e, 0x07, 0x90, 0x2a, 0xaa,
	0x54, 0x68, 0xce, 0x5d, 0xa5, 0x3e, 0xcc, 0x36, 0x6b, 0xf2, 0x0c, 0x36, 0x99, 0x48, 0x2d, 0xb1,
	0xb1, 0x94, 0xb8, 0xc1, 0x44, 0x8a, 0xb4, 0x85, 0xb6, 0x9a, 0x2b, 0xb4, 0xd5, 0xba, 0xa3, 0x2d,
	0x12, 0x03, 0x49, 0xb9, 0x54, 0x15, 0x8f, 0xb5, 0x99, 0xe1, 0x3a, 0xb5, 0x8d, 0x85, 0x7c, 0xbc,
	0x6c, 0x0e, 0x0e, 0xe7, 0x98, 0x28, 0x77, 0xb2, 0x46, 0xb7, 0xd3, 0x45, 0x70, 0x66, 0xdd, 0x1f,
	0x4d, 0xd8, 0x7e, 0x83, 0x63, 0xa6, 0x23, 0x29, 0xb5, 0x50, 0xe8, 0x5b, 0x93, 0xda, 0x85, 0x79,
	0x68, 0x0a, 0x16, 0xd9, 0x7b, 0xe6, 0x50, 0x8c, 0xc9, 0x73, 0xf0, 0xa4, 0x2e, 0xc2, 0xf2, 0x2a,
	0x94, 0xbf, 0xe8, 0xa8, 0x62, 0x69, 0x98, 0xb2, 0x5b, 0x1e, 0xe1, 0x7d, 0xc4, 0x3f, 0x8d, 0xbe,
	0x23, 0x75, 0xf1, 0xfd, 0xd5, 0xb9, 0xdd, 0x3d, 0x9c, 0x6c, 0x92, 0x21, 0xb4, 0xab, 0x48, 0x64,
	0xd6, 0x03, 0xb7, 0xff, 0xfc, 0xde, 0x8d, 0x05, 0xd4, 0xd0, 0xa9, 0x55, 0x21, 0x4f, 0xe0, 0xad,
	0x58, 0x27, 0x37, 0x4c, 0x85, 0x71, 0xa9, 0x45, 0x6a, 0x1f, 0x2a, 0x87, 0x6e, 0x59, 0x70, 0x80,
	0x18, 0xa1, 0xb0, 0x61, 0xd7, 0xd2, 0x5b, 0xc7, 0x6b, 0xf5, 0xe2, 0xfe, 0xa7, 0x0e, 0x50, 0x80,
	0x4e, 0x84, 0x76, 0x3e, 0x80, 0x36, 0x16, 0x62, 0x9e, 0xa7, 0x82, 0x0b, 0x74, 0xcc, 0xa1, 0x26,
	0x44, 0x24, 0xfa, 0xb5, 0xb6, 0xcb, 0x84, 0x3b, 0x8f, 0x61, 0xdd, 0xf2, 0xef, 0x76, 0x78, 0xf0,
	0x9b, 0x03, 0x8f, 0x78, 0xf9, 0x66, 0x51, 0x75, 0x39, 0x83, 0x2d, 0xfb, 0x50, 0xcb, 0x33, 0x83,
	0x9e, 0x39, 0x3f, 0xfe, 0x90, 0x71, 0x75, 0xad, 0xe3, 0x20, 0x29, 0x8b, 0x9e, 0x25, 0xec, 0x73,
	0x21, 0x55, 0xa5, 0x0b, 0x26, 0x14, 0xfa, 0xdc, 0x9b, 0x69, 0xed, 0xdb, 0x6f, 0x7b, 0xc6, 0xc4,
	0x7e, 0x56, 0x7f, 0xe2, 0x2d, 0x52, 0xab, 0xdb, 0xd9, 0x5e, 0xc7, 0x9f, 0x4f, 0xfe, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0x97, 0x6e, 0x37, 0xe3, 0x15, 0x08, 0x00, 0x00,
}
